<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4. Custom Widgets</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="TACTIC Developer" /><link rel="up" href="index.html" title="TACTIC Developer" /><link rel="prev" href="ar01s03.html" title="3. Changes" /><link rel="next" href="ar01s05.html" title="5. Plugins" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ar01s03.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s05.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_custom_widgets"></a>4. Custom Widgets</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_custom_layout_editor"></a>4.1. Custom Layout Editor</h3></div></div></div><p><span class="inlinemediaobject"><img src="media/custom_layout_editor_overview.png" alt="image" /></span></p><p><span class="strong"><strong>What the Custom Layout Editor Provides</strong></span></p><p>The Custom Layout Editor allows you to have complete control over the
look and feel of TACTIC using many of the standard web technologies
(HTML, CSS and Javascript). With this tool, you can build your own
TACTIC components (called widgets) that have the ability to interact
with one another intelligently, making it easier for you to design your
very own TACTIC interface.</p><p><span class="strong"><strong>HTML</strong></span></p><p>Custom Layouts enable the laying out of custom widgets using standard
HTML.</p><p><span class="strong"><strong>Element Tag</strong></span></p><p>TACTIC Custom Layout introduces a new html tag &lt;element&gt; which lets
TACTIC widgets to be embedded into HTML.</p><p>There are two formats for a TACTIC element: a short form and a long
form:</p><p>short form:</p><pre class="screen">&lt;element view='forms/my_form'/&gt;</pre><p>long form:</p><pre class="screen">&lt;element&gt;
  &lt;display class='tactic.ui.panel.CustomLayoutWdg'&gt;
    &lt;view&gt;forms/my_form&lt;/view&gt;
  &lt;/display&gt;
&lt;/element&gt;</pre><p>This ability to reference other views and elements makes it easy to keep
a top level view that draws from other views.</p><p>For display class names of other widgets, see section on Common Widgets.</p><p><span class="strong"><strong>Styles</strong></span></p><p>You can create styles for each view in the Styles tab. However, most of
the time it will be useful to reference a central stylesheet for a
number of views.</p><p>In order to include a top level stylesheet, you can create an empty view
with only styles defined and include these styles into other top level
views, just as how you would reference a normal view.</p><p>For example, you can create a view called <span class="emphasis"><em>common/styles</em></span> and add this
line to the HTML of a view where you want the styles to appear.</p><pre class="screen">&lt;element view='common/styles'/&gt;</pre><p><span class="strong"><strong>Behaviors</strong></span></p><p>TACTIC’s behavior system makes use of standard JavaScript behaviors with
the added functionality of some built-in classes.</p><p>Here are two ways to add an alert behavior to a button class called
<span class="emphasis"><em>my_button</em></span>.</p><pre class="screen">&lt;behavior class=”my_button” event='click_up'&gt;
alert('Hello World');
&lt;/behavior&gt;

&lt;behavior class='my_button'&gt;{
'type': 'click_up',
'cbjs_action': "'

alert('Hello World');

"'
}&lt;/behavior&gt;</pre><p>Here are the types of events that the TACTIC behavior system has
built-in support for:</p><pre class="screen">click_up | click | wheel | double_click | drag | hover | move | change | blur | mouseover | mouseout | keyup | keydown | listen</pre><p>You can set the behavior class to activate upon the firing of another
event using the <span class="emphasis"><em>listen</em></span> type event.</p><pre class="screen">&lt;behavior class='my_button'&gt;{
'type': 'click_up', 'cbjs_action': "'
spt.named_events.fire_event('my_event_trigger'); "'
}&lt;/behavior&gt;

&lt;behavior class='my_class'&gt;{
'type': 'listen',
'event_name': 'my_event_trigger',
'cbjs_action': "'

alert('Hello World');

"'
}&lt;/behavior&gt;</pre><p>When the behavior is applicable to a specific HTML element (eg. click,
click_up, mouseover, etc.), you can get element for which the behavior
originated from using the <span class="emphasis"><em>bvr.src_el</em></span> (Behavior Source Element) tag.</p><pre class="screen">var table = bvr.src_el.getParent('.my_table');
var cells = table.getElements('.my_cells');
cells.setStyle('background', 'red');</pre><p>TACTIC’s powerful framework comes with many API functions that make
developing for TACTIC easier. Here are some common ones.</p><p>Show loading popup:</p><pre class="screen">spt.app_busy.show('Saving data...')</pre><p>Hide loading popup:</p><pre class="screen">spt.app_busy.hide()</pre><p>Load an element:</p><pre class="screen">spt.panel.load(element_name, class_name, kwargs)</pre><p>Load an element into a popup:</p><pre class="screen">spt.panel.load_popup(element_name, class_name, kwargs)</pre><p>Close a popup:</p><pre class="screen">spt.popup.close(popup_element)</pre><p><span class="strong"><strong>Options</strong></span></p><p>The Custom Layout Editor’s Options tab incorporates the administrative
ability of modifying column, theme, view and table definitions with the
ability of creating these widgets. Various views, themes, columns and
tables can be created in the Custom Layout Editor with the desired
content and appearance.</p><p>Options of these custom features can be defined in the Options tab,
similar to how a predefined column or Column Manager custom column is
modified through the Edit Column Definition window. These options can be
set to change widget appearances, functions and behaviours, often in
addition to any options established in the HTML and Python tabs. Many of
the same options provided in the Edit Definition window are available
and can be used to customize created features.</p><p>The custom feature options are set through the use of Python in the
Options tab. A variety of different examples written in Python have been
shown below. They are structured exactly as they would need to be
defined in the Options tab with all possible subsets to refine a
particular option.</p><p><span class="emphasis"><em>Option Tab Examples</em></span></p><pre class="screen">    "mode": {
        'description': "Determines whether to draw with widgets or just use the raw data",
        'type': 'SelectWdg',
        'values': 'widget|raw',
        'order': 00,
        'category': 'Required'
    },
    "search_type": {
        'description': "search type that this panels works with",
        'type': 'TextWdg',
        'order': 01,
        'category': 'Required'
    },
    'expression': {
        'description': 'Use an expression to drive the search.  The expression must return sObjects e.g. @SOBJECT(sthpw/task)',
         'category': 'Display',
         'type': 'TextAreaWdg',
         'order': '01'
    },
    "element_names": {
        'description': "Comma delimited list of elemnent to view",
        'type': 'TextWdg',
        'order': 0,
        'category': 'Optional'
    }</pre><p>Customized options are also available to the user which offer additional
flexibility when modifying custom features. Some examples have been
provided below.</p><p><span class="emphasis"><em>Option Tab Custom Option Examples</em></span></p><pre class="screen">    {
    'basic_option': 'You can describe your option here',
    'advanced_option': { 'description' : 'You can describe your option here and in type specify what type of edit widget is used to display the option.',
                         'category': 'Display',
                         'type': 'TextWdg'
    }</pre><p><span class="strong"><strong>Images</strong></span></p><p>Images can be checked into TACTIC and used in interface design. In the
Files tab, you can check in images using the Check-in wizard.</p><p>Once the file is checked in, you use the web path as the URL of the
image.</p><p><span class="strong"><strong>Python</strong></span></p><p>TACTIC integrates the efficiency of Python in a Custom Layout Editor
tab, functioning together seamlessly with HTML, CSS and JavaScript. As
can be seen in the example below, Python works in connection with these
other languages to produce a desired output.</p><p><span class="emphasis"><em>Example</em></span></p><p>HTML code in Custom Layout Editor HTML tab:</p><pre class="screen">&lt;div class="hello_world"&gt;
    Hello World
&lt;/div&gt;</pre><p>CSS code in Custom Layout Editor Styles tab:</p><pre class="screen">.hello_world {
    font-size: 2em;
    padding: 1px;
    border: solid 1px black;
    background: ${background};
}</pre><p>Python code in Custom Layout Editor Python tab:</p><pre class="screen">background = "#F00"</pre><p>Custom Layout Editor Test Output:</p><p>The example demonstrates the use of Python in the creation of a title
block. Essentially, the Python coding is only setting the background
color of the title block. However, it can be used for more complicated
applications, as in the Testing Interface section.</p><p>The Python tab provides the user with the opportunity to use the Python
language in the editor without the restriction of having to explicitly
use embedded Mako, which is another TACTIC feature that is described in
the following section. The dedicated Python tab is an implicit
integration of Mako. Both Mako and the Python tab essentially use Mako
templating, while both providing equivalent Python utility and
efficiency.</p><p><span class="strong"><strong>Mako</strong></span></p><p>The custom layout engine embeds the Mako, a powerful templating engine
which allows you to embed Python scripts and logic within HTML. In order
to embed Python coding within the HTML, the code must be surrounded by
the special Mako tag: &lt;% {Python Code} %&gt;. Here is a simple example of
its usage:</p><pre class="screen">&lt;div&gt;
&lt;%
my_car = 'A ferrari'
%&gt;
&lt;/div&gt;
&lt;p&gt;${my_car}&lt;/p&gt;</pre><p>Mako makes passing and accessing of data in TACTIC easy, especially
combined with the support of XML by TACTIC widgets for passing
arguments.</p><p>The <span class="emphasis"><em>kwargs.get</em></span> function can be used to get the value of an XML
attribute of an element, whether it is an attribute already supported by
the element or an arbitrary one. Here is an example of setting a value
for an arbitrary attribute.</p><p>HTML code in top level view:</p><pre class="screen">&lt;element&gt;
  &lt;display class='tactic.ui.panel.CustomLayoutWdg'&gt;
    &lt;view&gt;my_forms.photoshoot_form&lt;/view&gt;
    &lt;args&gt;Hello&lt;/args&gt;
  &lt;/display&gt;
&lt;/element&gt;</pre><p>HTML code in a view named <span class="emphasis"><em>my_forms.photoshoot_form</em></span>:</p><pre class="screen">&lt;element&gt;
  &lt;display class='tactic.ui.input.TextInputWdg'&gt;
    &lt;default&gt;${kwargs.get("args")}&lt;/default&gt;
  &lt;/display&gt;
&lt;/element&gt;</pre><p>For the example above, the text field will be populated with the string
<span class="emphasis"><em>Hello</em></span>.</p><p>Most of the time, it will be beneficial to use Mako to pass search keys
from one view to another. That’s covered in a bit more detail in the
Creating Forms section of this document.</p><p><span class="strong"><strong>Injecting Widgets</strong></span></p><p>You can inject your custom widgets or TACTIC built-in widgets into your
view through the user interface. You can do it through the gear menu:</p><p><span class="inlinemediaobject"><img src="media/custom_layout_editor_gear_menu.PNG" alt="image" /></span></p><p>All these injection options allow you to inject the widget you want
directly where your cursor is in the code. All these injections have the
name field in common. The name field allows you to name your widget in
case you want to refer to it later in the code.</p><p><span class="strong"><strong>Inject Widget</strong></span> allows you to inject <span class="strong"><strong>any</strong></span> widget you want. You need to
define which widget to inject. You can select your widget through the
dropdown or select classpath and write the class path of a built-in
TACTIC widget. After selecting, a built-in widget, you may have to fill
in additional arguments which are required to successfully run the
widget.</p><p><span class="inlinemediaobject"><img src="media/inject_widget.png" alt="image" /></span></p><p>Similarly, you can inject a thumbnail, video, table, calendar, etc. and
customize the options respectively. The more popular widgets have been
added for your convenience to the gear menu. They are listed below.</p><p><span class="strong"><strong>Inject Thumbnail</strong></span> injects a thumbnail widget.</p><p><span class="strong"><strong>Inject Video</strong></span> injects a video.</p><p><span class="strong"><strong>Inject Text Input</strong></span> injects the text input field widget. You can specify
many options like the width of the input field.</p><p><span class="strong"><strong>Inject Look Ahead Text Input</strong></span> is similar except there is a look ahead
which comes with the input field.</p><p><span class="strong"><strong>Inject Layout</strong></span> injects a View Panel Widget.</p><p><span class="strong"><strong>Inject Table</strong></span> injects a Fast Table Layout Widget.</p><p><span class="strong"><strong>Inject Calendar</strong></span> injects a Calendar Widget.</p><p><span class="strong"><strong>Inject Search</strong></span> injects a Global Search Widget.</p><p><span class="strong"><strong>Inject Subscription</strong></span> injects a Subscription Bar Widget into your HTML.</p><p><span class="strong"><strong>Adding View to sidebar</strong></span></p><p><span class="inlinemediaobject"><img src="media/custom_layout_editor_sidebar.png" alt="image" /></span></p><p>You can add the view you have created directly to the sidebar. To do
this, click on the gear in the top menu and select “Add to Side Bar”.
This will add this view to the sidebar under the Project Views. By
default, It will get named according to the view name and “/” will be
treated as a space. For example, “app/chart” will be named “App Chart”.
You can always rename these views in the sidebar by right clicking on
them and selecting “Edit Side Bar”. Now select the view you want to edit
and change the Title field.</p><p><span class="strong"><strong>Creating URLs</strong></span></p><p>When you startup tactic and go to the main project URL
(…/tactic/&lt;project_name&gt;), you are presented with the tactic homepage of
the project. That tactic homepage URL can be changed to show one of your
created views. To do this, open up your view in the custom layout
editor, then from the gear menu select “Set as Project Url”. The current
view you have open will be shown when you go the main project URL. You
can come back to admin side of tactic by adding “/admin” to the URL
(…/tactic/&lt;project_name&gt;/admin).</p><p>You can also turn your view into a custom URL. This means that your view
will open when you go to a specific URL. To do this, open your view in
the custom layout editor, then from the gear menu select “Add as Custom
Url”. This will open up a dialog box where you can specify what URL
should open up the view. The URL specified there is showing the URL
which is appended to (…/tactic). You can specify which widget to run in
the URL in the widget field. By default, it shows the widget code for
the view that was open in the custom layout editor. You can check all
your custom URLs by going to the gear menu and selecting “Show Custom
URLs”. This will show all the existing custom URLs. This is where you
can delete existing custom URLs.</p><p><span class="strong"><strong>Creating Forms</strong></span></p><p>Forms provide an interface for updating TACTIC data. The Custom Layout
Editor makes the creation of forms easy with built-in widgets and
functions.</p><p>TACTIC already has some predefined input widgets that can be used as
input fields for forms, and they are referenced like any other widget.</p><p>TextInputWdg</p><p>SelectWdg</p><p>TextAreaWdg</p><p>CalendarInputWdg</p><p>ActionButtonWdg</p><pre class="screen">&lt;element name='my_text_input_field'&gt;
  &lt;display class='tactic.ui.input.TextInputWdg'&gt;
    &lt;default&gt;Hello&lt;/default&gt;
    &lt;width&gt;100px&lt;/width&gt;
  &lt;/display&gt;
&lt;/element&gt;</pre><p>You can find more details on the exact XML attributes that are supported
by each widget in the Common Widgets section.</p><p>Here are some useful functions for generating forms.</p><pre class="screen">spt.api.get_input_values(div_container)</pre><p>This gets the values of the all the input fields of a div as an array
with the attributes being the names of the element names.</p><pre class="screen">server.update(search_key, data)</pre><p>This updates an sobject with data that is passed in as an array.</p><p>The search key is a key that uniquely identifies an sobject.</p><p>Here is an example of usage of both for updating a TACTIC task through a
form.</p><p>In this example, the search key of an sobject is passed into the view
through a list of keyword arguments, and it is kept as a hidden input
for ease of access. The clicking of the save button activates the
behavior for saving the form.</p><pre class="screen">HTML: &lt;div class='spt_form'&gt;
  &lt;input type="hidden" name="spt_search_key" value="${kwargs.get('search_key')}"/&gt;
    &lt;element name='spt_status'&gt;
      &lt;display class='SelectWdg'&gt;
        &lt;values&gt;Assigned|Pending|Approved|Waiting&lt;/values&gt;
        &lt;search_key&gt;${kwargs.get("search_key")}&lt;/search_key&gt;
      &lt;/display&gt;
    &lt;/element&gt;

  &lt;input type="button" class="spt_save_button" value="Save &gt;&gt;"/&gt;
&lt;/div&gt;

JavaScript:

&lt;behavior class="spt_save_button&gt; {
"type": "click",
"cbjs_action": '''
  //gets the parent of the behavior source element
  var top = bvr.src_el.getParent('.spt_form');

  //gets all the input values
  var values = spt.api.get_input_values(top);

  var data = {
    //gets value of element named 'spt_status'
    //sets it as the value of the 'status' column for the task sobject
    status: values.spt_status;
  }

  search_key = values.spt_search_key;
  server.update(search_key, data) '''
}</pre><p><span class="strong"><strong>Testing Interface</strong></span></p><p>You can customize your views to behave during a testing phase. To do
this, you can add a condition in your code to check whether the code is
being run in testing mode. You can use the following condition in the
python section of the code:</p><pre class="screen">if kwargs.get("is_test") in [True, 'true']:</pre><p>This condition will be true if it is testing mode. You can now use this
condition to setup your variables correctly. You can run the view in
testing mode by clicking the test button in the top menu.</p><p><span class="inlinemediaobject"><img src="media/custom_layout_editor_testing.png" alt="image" /></span></p><p>In addition, these custom views can also be defined to take the form of
a specific view type: widget, column, chart, report or dashboard.</p><p>Widget is a free form view type. It is designed to allow your view to be
versatile in its presentation in TACTIC. These widget type views can
appear in stand-alone pop-up windows, tab view layouts, forms, tables,
text inputs, menus, or even buttons. An extension of this versatility
lies in their ability to be injected into other custom views as well,
much like what was described in the Injecting Widgets section.</p><p>Column allows for the customization of a table column. This column is
available to be added to any table through the Column Manager under
Plugin Widgets. The ability to modify the aesthetics and data
presentation of a column will allow the user to display the data they
want in a specific format. For example, if metadata for a particular
asset, such as an image, needs to be shown in a table, a column can be
formatted to list the metadata information through the use of an
embedded table, as shown below. Other formatting techniques, like
alternating row colors, can be added as well.</p><p><span class="emphasis"><em>Example</em></span></p><p>HTML code in HTML Custom Layout tab:</p><pre class="screen">&lt;div&gt;
&lt;%
table = []
table.append("&lt;table cellpadding='4px'&gt;")
i = 0
for name, value in data.items():
    i = i + 1
    if (i % 2 == 0):
        table.append("&lt;tr style='background: #BBB'&gt;")
    else:
        table.append("&lt;tr style='background: #DDD'&gt;")

    table.append("&lt;td style='width: 100px'&gt;%s&lt;/td&gt;" % name)
    table.append("&lt;td&gt;%s&lt;/td&gt;" % value)
    table.append("&lt;/tr&gt;")

table.append("&lt;/table&gt;")
table = "".join(table)

context.write(table)
%&gt;
&lt;/div&gt;</pre><p>Python code in Custom Layout Python tab:</p><pre class="screen">data = {
    'Frame Size:': "768 x 512",
    'Colorspace:': "yuvj420p",
    'Location:': "C:\...\",
    'File Type:': "MJPEG (Motion JPEG)",
}</pre><p>Output Column in Table:</p><p>Chart, report and dashboard view types present the ability to create
customized charts, reports and dashboards that are easily accessible to
users. Custom views can be defined to present data in the form of line
charts, budgeting reports or department specific dashboards that display
tables or views that are commonly used by that department.</p><p>However, only by specifying the view type do these views become easily
accessible to users. For example, by setting a custom layout view to
Chart, in the Examples section under Project Configuration, this custom
view will be added to the list of charts that are already available. By
selecting the drop down arrow menu on the created chart icon, there is
an option to "Add to Side Bar". This will add this chart view to the
side bar for easy accessibility, under a defined "Chart" section.</p><p>In addition, if a custom theme is created and utilizes sidebar views and
associated links in the menu, this new chart view will be automatically
added in the menu of theme.</p><p>To begin a custom chart, report or dashboard, going to the Examples
section under the Project Configuration is a good place to establish a
base to build one of these customized tools. For example, by selecting
Dashboards in the Examples section, a selection of different sample
dashboards will be displayed. If one of the dashboards is of particular
interest, but requires some modification, by going to the arrow drop
down menu on the dashboard icon and selecting "Show Definition", the
definition can be copied and pasted in the Custom Layout Editor and
modified to the desired appearance.</p><p><span class="strong"><strong>Tips and Techniques:</strong></span></p><p><span class="strong"><strong>Handling None</strong></span></p><p>The default value for the empty string in Python is the word "None".
This does not help very much when you want to obtain something like the
search key of an sobject because if there is no search key, instead of
getting an empty string, you get the string "None". And if you try to
pass "None" into an element, an error will likely result.</p><p>The way to work around that is to add an "or" at the end of your
kwargs.get function.</p><pre class="screen">ie: kwargs.get("search_key") or ""</pre><p><span class="strong"><strong>Embed Elements</strong></span></p><p>A shortcut for embedding elements into the HTML is by clicking on the
gear menu.</p><p>Similarly, if you would like to inject another view into your current
view, you can do so by right clicking on the view you want to inject.</p><p><span class="strong"><strong>Element Name as Column of sObject</strong></span></p><p>If you pass a search key into an element, it automatically takes the
element name as the column if you do not specify one. In the example
below, the text input will display the id of the sObject with the given
search key.</p><pre class="screen">&lt;element name="id"&gt;
  &lt;display class="tactic.ui.input.TextInputWdg"&gt;
    &lt;search_key&gt;${search_key}&lt;/search_key&gt;
    &lt;width&gt;100px&lt;/width&gt;
  &lt;/display&gt;
&lt;/element&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_widget_development"></a>4.2. Widget Development</h3></div></div></div><p>As of 2.5, all widgets are derived from BaseRefreshWdg. This refresh
widget is a new style widget which has some added functionality allowing
to to be "smart" enough to refresh itself. It also standardizes the
interface for passing construction parameters to the widget. All new
style widgets take kwargs (keyword arguments) as argumets to the
constructor</p><pre class="screen">widget = MyWidget(option1=value1, option2=value2)</pre><p>All new style widgets defined a method called "get_args_keys", which
return a dictionary of defined and allowable arguments:</p><pre class="screen">def get_args_keys(my):
  return {
    "option1": "this is option #1",
    "option2": "this is option #2"
  }</pre><p>TACTIC provides the ability to create your own widgets and integrate
them seamlessly into the TACTIC interface.</p><p>There are 3 main types of widgets:</p><p>*Widget:*A widget derived from a the base Widget class is a free
standing widget that requires no parent widget.</p><p>*Table Element Widget:*An element widget is a widget that needs expected
to be put inside a TableLayoutWdg.</p><p>*Input Widget:*An input widget is a widget that requires one or more
values to put entered or extracted.</p><p><span class="strong"><strong>Create your own custom widget</strong></span></p><p>You can create your own custom widgets in Tactic that become completely
integrated in the user interface.</p><p>All widgets are derived from the base Widget (pyasm.web.Widget) class.
This class defines the fundamental functionality required for all
widgets that appear in TACTIC. To create your own widget, you can derive
off of this class.</p><p><span class="strong"><strong>Hello World</strong></span></p><p>In order to start showing how custom widgets can be created, we will
start with the base "Hello World" widget. Create a folder called
"custom" and then create a new file called "hello_world_wdg.py" in this
new folder. In the file add the following lines:</p><pre class="screen">from pyasm web import Widget

class HelloWorldWdg(Widget):
    def get_display(my):
        return "Hello World"</pre><p>In order for TACTIC to be able to use this class,TACTIC must be able to
see this file: this "custom" folder must be either in the PYTHONPATH or
in sys.path of the TACTIC process (you can alternatively, use any class
that complies with Python’s module handling.</p><div class="blockquote"><blockquote class="blockquote"><p><span class="strong"><strong>Note</strong></span></p><p>You can also use the python_path variable in the TACTIC config file to
add paths to the sys.path dictionary</p></blockquote></div><p>In order to view this widget quickly, you can open up the javascript
editory and type:</p><pre class="screen">spt.panel.load("custom.hello_world_wdg.HelloWorldWdg");</pre><p>and press the "Run" button. You should see the following:</p><p><span class="inlinemediaobject"><img src="media/widgetDevelopment_01.png" alt="image" /></span></p><p>Note that the title does not change. This is something that the link
will do automatically.</p><p><span class="strong"><strong>Formatting the Widget</strong></span></p><p>We could format the widge a litlle more using some basic HTML widgets.</p><pre class="screen">from pyasm.web import Widget, DivWdg

class HelloWorldWdg2(Widget):
    def get_display(my):
        top = DivWdg()
        top.add_style("font-size: 15px")
        top.add_style("margin: 30px")
        top.add_style("padding: 30px")
        top.add_style("width: 150px")
        top.add_style("text-align: center")
        top.add_style("border: solid 1px black")

        top.add("Hello World")

        return top</pre><p>Adding this to a file called hello_world_wdg2.py and then in javascript
editor, type:</p><pre class="screen">spt.panel.load("custom.hello_world_wdg2.HelloWorldWdg2");</pre><p>Pressing the "Run" button gives:</p><p><span class="inlinemediaobject"><img src="media/widgetDevelopment_02.png" alt="image" /></span></p><p><span class="strong"><strong>HTML</strong></span></p><p>Here we introduce the basic HTML widget DivWdg. The add_style() allows
you to add arbitrary CSS styles to the widget. There are various
operations that can be added to HTML widgets that are useful for
formatting the layout of the page. These methods include:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
set_attr(name, value)
</li><li class="listitem">
add_style(name, value)
</li><li class="listitem">
add_class(css_class)
</li><li class="listitem">
add_event(event, js_action)
</li></ul></div><p>There are few useful predefined widgets that sit on top of HtmlElement:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
DivWdg
</li><li class="listitem">
SpanWdg
</li><li class="listitem">
Table
</li></ul></div><p>These are all based of of HtmlElement which are basic html elements and
provide a thin layer above HTML.  HtmlElement also defines a number of
static constructors to address most HTML elements:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
HtmlElement.br()
</li><li class="listitem">
HtmlElement.p()
</li><li class="listitem">
HtmlElement.br()
</li></ul></div><p>These return variations of HtmlElement that represent the different HTML
elements. These are useful for laying out a complex widget. All HTML
elements and their properties are accessible from these.</p><p><span class="strong"><strong>Using other widgets</strong></span></p><p>You can add other predefined widget, for example, the CalendarWdg</p><pre class="screen">from pyasm.web import Widget, DivWdg

from tactic.ui.widget import CalendarWdg

class HelloWorldWdg3(Widget):
    def get_display(my):
        top = DivWdg()
        top.add_style("font-size: 15px")
        top.add_style("margin: 30px")
        top.add_style("padding: 30px")
        top.add_style("width: 200px")
        top.add_style("text-align: center")
        top.add_style("border: solid 1px black")

        top.add("Hello World")

        calendar = CalendarWdg()
        top.add(calendar)

        return top</pre><p>Adding this to a file called hello_world_wdg3.py and then in javascript
editor, type:</p><pre class="screen">spt.panel.load("custom.hello_world_wdg3.HelloWorldWdg3");</pre><p>Pressing the "Run" button gives:</p><p><span class="inlinemediaobject"><img src="media/widgetDevelopment_03.png" alt="image" /></span></p><p>This adds one of the predefined widget "CalendarWdg". Widgets are
hierarchical and can be added to other widgets. Any widget can embed any
other widget within it’s display. This provides a very flexible
archictecure for building up complex hierarchical widgets.</p><p><span class="strong"><strong>Create your own table element widget</strong></span></p><p>There is a special class of widgets that are designed to be used in
conjuntion with TableLayoutWdg, the primary widget used for laying out
tabular data. These widgets should be derived from BaseTableElementWdg,
which extends the basic Widget class with a number of specific methods.</p><p>The TableLayoutWdg uses it’s child widgets slightly differently than
most widgets. It creates a single widget for each column and calls the
get_display() method repeatedly for each row; each row representing a
single sobject. Each element widgets does have knowledge of all of the
sobjects, however, for each row, there will be a current sobject set.
This means that the widgets get_display() method will be called
repeatedly for each row. So, instead of operating on a list of widgets,
the table element widget should get the current widget using the
"get_current_widget()" method.</p><p>The following is a simple example of a table element widget.</p><pre class="screen">from pyasm.web import DivWdg
from tactic.ui.common import BaseTableElementWdg

class MyElementWdg(BaseTableElementWdg):
    def get_display(my):
        sobject = my.get_current_sobject()
        first_name = sobject.get_value("first_name")
        last_name = sobject.get_value("last_name")
        div = DivWdg()
        div.add("%s %s" % (first_name, last_name) )
        return div</pre><p>The class is almost identical to a regular class, except that it is
derived from BaseTableElementWdg and that it uses get_current_sobject()
to get the current sobject being drawn. This widget still has access to
all of the sobjects in all of the rows, through get_sobjects(), if this
is necessary.</p><p>To test this, save the code above in a file called my_element_wdg.py and
enter this into the javascript editor:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="strong"><strong>Note</strong></span></p><p>This only works in 2.6: in 2.5, you have to create the view in the
widget config table</p></blockquote></div><pre class="screen">var config = " \
&lt;config&gt;&lt;test&gt;  \
&lt;element name='name'&gt;  \
  &lt;display class='custom.my_element_wdg.MyElementWdg'/&gt; \
&lt;/element&gt; \
&lt;/test&gt;&lt;/config&gt;";

var args = {
  'search_type': 'sthpw/login',
  'view': 'test',
  'config_xml': config,
  'do_search': 'true'
};
spt.panel.load("main_body", "tactic.ui.panel.TableLayoutWdg", args);</pre><p>Pressing the "Run" button gives:</p><p><span class="inlinemediaobject"><img src="media/widgetDevelopment_04.png" alt="image" /></span></p><p>Your custom table element widget completely integrates within the TACTIC
interface. You can add other widgets by expanding the config definition.</p><pre class="screen">var config = " \
&lt;config&gt;&lt;test&gt;  \
&lt;element name='preview'/&gt;  \
&lt;element name='name'&gt;  \
  &lt;display class='custom.my_element_wdg.MyElementWdg'/&gt; \
&lt;/element&gt; \
&lt;element name='email'/&gt;  \
&lt;/test&gt;&lt;/config&gt;";

var args = {
  'search_type': 'sthpw/login',
  'view': 'test',
  'config_xml': config,
  'do_search': 'true'
};
spt.panel.load("main_body", "tactic.ui.panel.TableLayoutWdg", args);</pre><p>This adds a preview and an email column (which are predefined for
sthpw/login search type) and appear with your custom widget.</p><p><span class="inlinemediaobject"><img src="media/widgetDevelopment_05.png" alt="image" /></span></p><p><span class="strong"><strong>BaseTableElementWdg</strong></span></p><p>This example describes how to create your own BaseTableElementWdg to
execute a server-side command. The user can type some words in the text
field, and then click on the "Action" button. The words will be written
as the content of a file in the /tmp folder of the server. In the tactic
config file, tactic_linux-conf.xml, let’s say the python_path is
<span class="emphasis"><em>/home/apache/custom</em></span>. You can create a file called custom_wdg.py and
<span class="emphasis"><em>init</em></span>.py in it.</p><p><span class="inlinemediaobject"><img src="media/widgetDevelopment_custom_table_element_wdg.png" alt="image" /></span></p><p>Here is the content of<span class="emphasis"><em>init</em></span>.py:</p><pre class="screen">from custom_wdg import *</pre><p>Here is the content of custom_wdg.py:</p><pre class="screen">__all__ = ['CustomToolElementWdg','CustomCmd']

from tactic.ui.common import BaseTableElementWdg
from tactic.ui.widget import ActionButtonWdg
from pyasm.web import HtmlElement, SpanWdg
from pyasm.widget import TextWdg
from pyasm.command import Command

class CustomToolElementWdg(BaseTableElementWdg):

    def get_display(my):

        top = DivWdg()
        top.add_class('spt_custom_tool_top')
        text = TextWdg('user_input')

        action_button = ActionButtonWdg(title='Action', tip='Write a file in /tmp based on the data in the text field')
        action_button.add_behavior({'type':'click_up',
            'cbjs_action': '''var server = TacticServerStub.get();
            try {
                var top = bvr.src_el.getParent(".spt_custom_tool_top");
                var values = spt.api.get_input_values(top, null, false);

                # this path is assumed importable in your Python environment
                server.execute_cmd('custom_wdg.CustomCmd', values);
            }
            catch(e) {
                alert(spt.exception.handler(e));
            }
            '''})

        top.add(SpanWdg('Input:', css='small'))
        top.add(text)
        top.add(HtmlElement.br())
        top.add(action_button)

        return top

class CustomCmd(Command):

    def execute(my):
        text = my.kwargs.get('user_input')
        f = open('/tmp/my_file.txt','w')
        f.write(text)
        f.close()</pre><p>If you click the first "Action" button, a file with "Hello !!!" will be
created. On clicking the second "Action" button, the file content will
be replaced with the word "example".</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_widget_architecture"></a>4.3. Widget Architecture</h3></div></div></div><p><span class="strong"><strong>What are Widgets?</strong></span></p><p>Widgets are drawable entities. They have the ability to draw themselves
and also have the ability to contain other widgets and call on their
drawing.</p><p><span class="strong"><strong>Widget Architecture?</strong></span></p><p>The TACTIC interface is entirely built on top of widget architecture. A
widget has a drawing mechanism which displays the widget. Widgets can
contain any number of other widgets and pass information to them.</p><p>Certain widgets also make use of configuration xml documents in order to
configure how they should be drawn. These configs are useful because
they allow very quick and readable configuration of complex widgets.
This document can also be stored in the database as a way of remembering
the state of how to redraw a particular widget. This is widely used in
TACTIC to store various parts of the interface in the database.</p><p>Every widget has a display method which completely controls how a widget
is displayed. This display is recursive as each widget will call all of
it’s children’s display method. In this manner, the entire interface is
build up.</p><p>Widgets derive data to draw from sobjects. Generally a search is
performed to retrieve sobjects which are then used to draw the widget.
The widget itself can perform the search or it can recieve sobjects from
some external source.</p><p><span class="strong"><strong>Widget Config</strong></span></p><p>Numerous widgets use configuration xml documents to help them draw their
display. These widgets are considered to be "layout" widgets in that
they generally use the configurations to determine what the child
widgets are and how and where they are drawn within the parent layout
widget. The widget config is an xml document which describes the child
elements and how they should be display. The format is defined as
follows.</p><pre class="screen">&lt;config&gt;
  &lt;VIEW&gt;
    &lt;element name='NAME'  OPTION='VALUE'&gt;
      &lt;display class='CLASS_PATH'&gt;
        &lt;KWARG&gt;VALUE&lt;/KWARG&gt;
        &lt;KWARG&gt;VALUE&lt;/KWARG&gt;
      &lt;/dispaly&gt;
    &lt;/element&gt;
    &lt;element name='NAME' OPTION='VALUE'&gt;
      &lt;display class='CLASS_PATH'&gt;
        &lt;KWARG&gt;VALUE&lt;/KWARG&gt;
        &lt;KWARG&gt;VALUE&lt;/KWARG&gt;
      &lt;/dispaly&gt;
    &lt;/element&gt;
  &lt;/VIEW&gt;
&lt;/config&gt;</pre><p>Where capitalized words represent variable entries.</p><div class="informaltable"><table cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>VIEW</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The name of a view which encompases a particular configuration.
There can be any number of views in a configuration documentation</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>OPTION</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>An option defining a state or setting of this element. This
information does not get passed to the element widget</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>VALUE</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>A value or a particular argument or options</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>CLASS_PATH</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The fully qualified python path of the widget class</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>KWARG</p></td><td style="" align="left" valign="top"><p>A kwarg that is passed to the class on construction</p></td></tr></tbody></table></div><p>A simple example of a configuration is as follows:</p><pre class="screen">&lt;config&gt;
&lt;simple&gt;
  &lt;element name='email'&gt;
    &lt;display class='custom.MyCustomWdg'&gt;
      &lt;title&gt;My Widget&lt;/title&gt;
    &lt;/display&gt;
  &lt;/element&gt;
&lt;/simple&gt;
&lt;/config&gt;</pre><p>In this case, the "simple" view defines a single element called "email".
This element</p><p>The configuration document can contain any number of "views". Each
"view" can contain any number of elements. Inside each element, there
are xml snippets which represents an xml serialization of a widget. In
the example above:</p><pre class="screen">&lt;display class='custom.MyCustomWdg'&gt;
  &lt;title&gt;My Widget&lt;/title&gt;
&lt;/display&gt;</pre><p>translates into python server code as follows:</p><pre class="screen">from custom import MyCustomWdg
widget = MyCustomWdg(title='My Widget')</pre><p>TACTIC uses this format extensively to serialize widgets to the
database. Although any source can be used, the config is most often
defined in the widget config table of a particular project.</p><p>There are a couple of layout classes that make heavy use of the widget
config.</p><p><span class="strong"><strong>SideBarWdg:</strong></span></p><p><span class="strong"><strong>TableLayoutWdg:</strong></span> this class is the used to display most tabular data in
TACTIC. It contains many features to make the display of tabular data
dynamic and flexible. Views can be customized and saved. It is probably
the most used layout class in TACTIC. It makes heavy use of the widget
config for its display. It’s importance is sufficient to warrent a
section on its own below.</p><p><span class="strong"><strong>CustomLayoutWdg:</strong></span> this class makes use of a special version of the
config. It defines elements, but they are defined within an html tag,
allowing for precise layout of elements using HTML. This allows for very
flexible layouts while still being able make use of TACTIC widgets.</p><p><span class="strong"><strong>SideBarWdg</strong></span></p><p>The SideBarWdg defines the look of the side bar on the left of the
TACTIC interface. The SideBarWdg makes heavy use of the widget config to
determine the contents of the side bar. There are 3 main types of
widgets that would be defined as elements in the SideBarWdg:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
LinkWdg
</li><li class="listitem">
FolderWdg (Currently SectionWdg)
</li><li class="listitem">
SeparatorWdg
</li></ul></div><p>The top level view for the project views can be found in the widget
config table with the criteria:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
search_type = <span class="emphasis"><em>SideBarWdg</em></span>
</li><li class="listitem">
view = <span class="emphasis"><em>project_view</em></span>
</li></ul></div><p>This will defined a list of elements that appear in the top level of the
"Project View". An example would look like the following:</p><pre class="screen">&lt;config&gt;
  &lt;project_view&gt;
    &lt;element name='summary'/&gt;
    &lt;element name='modeling'/&gt;
  &lt;/project_view&gt;
&lt;/config&gt;</pre><p>Although, you could defined the display section here, there are are
hierarchical definitions to the elements. If a definition is not found
inline, TACTIC will look at the the database for the specially named
"definition" view.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
search_type = <span class="emphasis"><em>SideBarWdg</em></span>
</li><li class="listitem">
view = <span class="emphasis"><em>definition</em></span>
</li></ul></div><pre class="screen">&lt;config&gt;
  &lt;definition&gt;
    &lt;element name='summary' title='Asset Summary'&gt;
      &lt;display class='LinkWdg'&gt;
        &lt;class_name&gt;tactic.ui.panel.ViewPanelWdg&lt;/class_name&gt;
        &lt;search_type&gt;prod/asset&lt;/search_type&gt;
        &lt;view&gt;summary&lt;/view&gt;
      &lt;/display&gt;
    &lt;/element&gt;
    &lt;element name='modeling' title='Modelling'&gt;
      &lt;display class='FolderWdg'&gt;
        &lt;view&gt;modeling&lt;/view&gt;
      &lt;/display&gt;
    &lt;/element&gt;
  &lt;/definition&gt;
&lt;/config&gt;</pre><p>Both the summary and modeling elements are defined in this special
"definition" view"</p><p>Since all of the folders at all levels cascade to look at the
"definition" view, it is useful to always define defintions of elements
in the "definiton" view. This will allow a consistent definition for all
of the "views" in the project view.</p><p>The "summary" view is defined as a LinkWdg. This widget takes the
information defined in the options and then displays that class in the
main body of the TACTIC interface.</p><pre class="screen">widget = ViewPanelWdg( search_type='prod/asset', view='summary' )</pre><p>As stated ealier, the ViewPanelWdg, combines a SearchWdg with a
TableLayoutWdg.</p><p>The second element defines a "modeling" folder. Whe a folder is click,
it will open up and display another list that is derived from the
"modeling" view.</p><p><span class="strong"><strong>TableLayoutWdg</strong></span></p><p>This widget is the primary class used in TACTIC to lay out tabular data.
It makes heavy use of widget config to define what to display.</p><p>To display the rows and columns of the tabular layout, this widget makes
use of the following:</p><p>\a) rows which are sobjects</p><p>\b) columns which are widgets derived from BaseTableElementWdg.</p><p>The table layout widget is able to perform a search base on input
criteria. It is also able to receive sobjects through its set_objects()
method.</p><p>This widget iterates through each of the sobjects per row.</p><p>For each column, the table draws the list of widgets provided by the
config. This config is typically defined in in the database in the
widget config table.</p><p>Two parameters are typcially used to find a particular widget config.</p><p>\a) Search Type</p><p>\b) View</p><p><span class="strong"><strong>BaseTableElementWdg</strong></span></p><p>BaseTableElementWdg are extensively used in the UI. Each column in a
table you see in TACTIC derives from it. For examples of how to create
your own, please refer to the Widget Development section.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s03.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>